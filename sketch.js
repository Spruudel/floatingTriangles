let debugging = false;

let particles = [];
let bholes = [];
let suns = [];

let maxDistance = 180;
let gravity = 0.00009;

let grid;

let partGrid;
let holeGrid;
let sunGrid;

let gridWidth;
let gridHeight;


function setup() {
	createCanvas(windowWidth, windowHeight);
	frameRate(60);
	angleMode(DEGREES);

	var number = Math.floor((windowWidth * windowHeight) / 32914); // Generated by using (1920*1200) / x = 70, as this seemed to be okay
	for (let i = 0; i < number; i++) {
		particles.push(new Particle(random(width), random(height)));
	}

	gridWidth = ceil(windowWidth / maxDistance);
	gridHeight = ceil(windowHeight / maxDistance);
}

function draw() {
	background(51);

	updateGrid();

	if (debugging == true) {
		stroke(115, 100);
		for (let i = 0; i < gridWidth; i++) line(i * maxDistance, 0, i * maxDistance, windowHeight);

		for (let i = 0; i < gridHeight; i++) line(0, i * maxDistance, windowWidth, i * maxDistance);

		for (let x = 0; x < gridWidth; x++) {
			for (let y = 0; y < gridHeight; y++) {
				fill(255, 180);
				text(grid[0][x][y].length + grid[1][x][y].length + grid[2][x][y].length, x * maxDistance + 10, y * maxDistance + 20);
			}
		}
	}

	// Black Hole
	for (var i = 0; i < bholes.length; i++) {
		noStroke();
		bholes[i].show();
	}

	// Sun
	for (var i = 0; i < suns.length; i++) {
		noStroke();
		suns[i].show();
	}

	// Particle
	for (var i = 0; i < particles.length; i++) {
		if (particles[i].offScreen()) {
			particles.splice(i, 1);
			newParticle();
		}
	}

	for (var i = 0; i < particles.length; i++) {
		particles[i].move();
		noStroke();
		particles[i].show();
	}

	// Particle - Particle lines
	stroke(115, 80);
	for (let i = 0; i < particles.length; i++) {
		let neighbours = particles[i].checkDist();
		if (neighbours.length > 0) {
			for (let j = 0; j < neighbours.length; j++) {
				line(particles[i].pos.x, particles[i].pos.y, particles[neighbours[j]].pos.x, particles[neighbours[j]].pos.y);
			}
		}
	}

	// Black Hole: Gravity and Destruction
	for (let i = 0; i < bholes.length; i++) {
		let neighbours = bholes[i].checkDist();
		if (neighbours.length > 0) {
			for (let j = 0; j < neighbours.length; j++) {
				let curNeighbour = particles[neighbours[j]];

				let vecPartToHole = p5.Vector.sub(bholes[i].pos, curNeighbour.pos);

				if (vecPartToHole.mag() <= bholes[i].r - curNeighbour.r * 2) {
					if (curNeighbour.dying > 0) {
						curNeighbour.r = lerp(0, curNeighbour.initR, curNeighbour.dying);
						curNeighbour.dying = (curNeighbour.dying - curNeighbour.dyingRate < 0) ? 0 : curNeighbour.dying - curNeighbour.dyingRate;
					} else {
						particles.splice(neighbours[j], 1);
						newParticle();
					}
				}

				let distProp = (maxDistance - vecPartToHole.mag()) / maxDistance;

				curNeighbour.vel.add(p5.Vector.mult(vecPartToHole, distProp * gravity));
			}
		}
	}

	// Sun: Gravity and Destruction and Light??
	for (let i = 0; i < suns.length; i++) {
		let neighbours = suns[i].checkDist();
		if (neighbours.length > 0) {
			for (let j = 0; j < neighbours.length; j++) {
				let curNeighbour = particles[neighbours[j]];

				let vecPartToHole = p5.Vector.sub(suns[i].pos, curNeighbour.pos);

				if (vecPartToHole.mag() <= suns[i].r - curNeighbour.r * 2) {
					if (curNeighbour.dying > 0) {
						curNeighbour.r = lerp(0, curNeighbour.initR, curNeighbour.dying);
						curNeighbour.dying = (curNeighbour.dying - curNeighbour.dyingRate < 0) ? 0 : curNeighbour.dying - curNeighbour.dyingRate;
					} else {
						particles.splice(neighbours[j], 1);
						newParticle();
					}
				}

				let distProp = (maxDistance - vecPartToHole.mag()) / maxDistance;

				curNeighbour.vel.add(p5.Vector.mult(vecPartToHole, distProp * gravity));
			}
		}
	}

	// Shadows
	push();
	for (let i = 0; i < suns.length; i++) {
		for (var j = 0; j < particles.length; j++) {
			let curParticle = particles[j];

			let vecSunToPart = p5.Vector.sub(curParticle.pos, suns[i].pos);

			let PointR = p5.Vector.add(curParticle.pos, vecSunToPart.copy().rotate(90).normalize().mult(curParticle.r));
			let PointL = p5.Vector.add(curParticle.pos, vecSunToPart.copy().rotate(-90).normalize().mult(curParticle.r));

			fill(0, 30);
			noStroke();
			ellipse(PointL.x, PointL.y, 1, 1);
			ellipse(PointR.x, PointR.y, 1, 1);

			let rectEndR = PointR.copy().add(vecSunToPart.copy().setMag(windowWidth > windowHeight ? windowWidth * 2 : windowHeight * 2));
			let rectEndL = PointL.copy().add(vecSunToPart.copy().setMag(windowWidth > windowHeight ? windowWidth * 2 : windowHeight * 2));

			beginShape();

			vertex(PointL.x, PointL.y);
			vertex(PointR.x, PointR.y);
			vertex(rectEndR.x, rectEndR.y);
			vertex(rectEndL.x, rectEndL.y);

			endShape(CLOSE);

		}
	}
	pop();

	// it dark
	push();
	noFill();
	for (var i = 0; i < suns.length; i++) {
		for (var j = 0; j < suns[i].radiance; j++) {
			stroke(0, j / suns[i].radiance * 255);
			ellipse(suns[i].pos.x, suns[i].pos.y, j);
		}
	}

	pop();
}

function mouseClicked() {
	if (keyIsDown(SHIFT) && suns.length < 1)
		suns.push(new Sun(mouseX, mouseY));
	else if (!keyIsDown(SHIFT))
		bholes.push(new BHole(mouseX, mouseY));
	return false;
}


function newParticle() {
	particles.push(new Particle(random(width), random(height)));
}

function updateGrid() {
	partGrid = [];

	for (let i = 0; i < gridWidth; i++) {
		partGrid.push([]);
		for (let k = 0; k < gridHeight; k++) {
			partGrid[i].push([]);
		}
	}

	for (let i = 0; i < particles.length; i++) {
		gridPos = particles[i].gridPos();
		partGrid[gridPos[0]][gridPos[1]].push(i);
	}


	holeGrid = [];

	for (let i = 0; i < gridWidth; i++) {
		holeGrid.push([]);
		for (let k = 0; k < gridHeight; k++) {
			holeGrid[i].push([]);
		}
	}

	for (let i = 0; i < bholes.length; i++) {
		gridPos = bholes[i].gridPos();
		holeGrid[gridPos[0]][gridPos[1]].push(i);
	}

	sunGrid = [];

	for (let i = 0; i < gridWidth; i++) {
		sunGrid.push([]);
		for (let k = 0; k < gridHeight; k++) {
			sunGrid[i].push([]);
		}
	}

	for (let i = 0; i < suns.length; i++) {
		gridPos = suns[i].gridPos();
		sunGrid[gridPos[0]][gridPos[1]].push(i);
	}

	grid = [];
	grid[0] = partGrid;
	grid[1] = holeGrid;
	grid[2] = sunGrid;
}