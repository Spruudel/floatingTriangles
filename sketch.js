let DEBUGGING = false;
p5.disableFriendlyErrors = true;

let ANIM_SPEED = 0.007;

let MAX_DISTANCE = 180;
let GRAVITY = 0.00009;

let BHOLE_R = 20;
let SUN_R = 20;

let BHOLE_COLOR;
let SUN_COLOR;
let BHOLE_ALPHA = 225;
let SUN_ALPHA = 240;

let BHOLE_N_ANIM_PARTICLE_WAVES = 20;
let SUN_N_ANIM_PARTICLE_WAVES = 20;

let BHOLE_ANGLE_DISTANCE = 40;
let SUN_ANGLE_DISTANCE = 40;

let BHOLE_ANIM_FRAMES = (1 / BHOLE_N_ANIM_PARTICLE_WAVES) / ANIM_SPEED;
let SUN_ANIM_FRAMES = (1 / SUN_N_ANIM_PARTICLE_WAVES) / ANIM_SPEED;


let particles = [];
let bholes = [];
let suns = [];

let grid;
let partGrid, holeGrid, sunGrid;

let gridWidth, gridHeight;

let maxScreen;

let sun_overlay;
let bHoleAnim = [],
	sunAnim = [];

function preload() {
	sun_overlay = loadImage('assets/sun_overlay2.png');

	BHOLE_COLOR = color('#000000');
	SUN_COLOR = color('#FFCC00');

	bHoleAnim = createAnim(BHOLE_R, BHOLE_ANGLE_DISTANCE, BHOLE_N_ANIM_PARTICLE_WAVES, BHOLE_COLOR, BHOLE_ALPHA, ANIM_SPEED, BHOLE_ANIM_FRAMES);
	sunAnim = createAnim(SUN_R, SUN_ANGLE_DISTANCE, SUN_N_ANIM_PARTICLE_WAVES, SUN_COLOR, SUN_ALPHA, ANIM_SPEED, SUN_ANIM_FRAMES);
};

function setup() {
	createCanvas(windowWidth, windowHeight);
	//createCanvas(BHOLE_R * 5, BHOLE_R * 5);
	frameRate(30);
	angleMode(DEGREES);

	let number = Math.floor((windowWidth * windowHeight) / 32914); // Generated by using (1920*1200) / x = 70, as this seemed to be okay
	for (let i = 0; i < number; i++) {
		particles.push(new Particle(random(width), random(height)));
	}

	gridWidth = ceil(windowWidth / MAX_DISTANCE);
	gridHeight = ceil(windowHeight / MAX_DISTANCE);

}

function draw() {
	background(51);

	updateGrid();

	if (DEBUGGING == true) {
		stroke(115, 100);
		for (let i = 0; i < gridWidth; i++) line(i * MAX_DISTANCE, 0, i * MAX_DISTANCE, windowHeight);

		for (let i = 0; i < gridHeight; i++) line(0, i * MAX_DISTANCE, windowWidth, i * MAX_DISTANCE);

		for (let x = 0; x < gridWidth; x++) {
			for (let y = 0; y < gridHeight; y++) {
				fill(255, 180);
				text(grid[0][x][y].length + grid[1][x][y].length + grid[2][x][y].length, x * MAX_DISTANCE + 10, y * MAX_DISTANCE + 20);
			}
		}
	}

	// Particle - Particle lines
	stroke(115, 80);
	for (let i = 0; i < particles.length; i++) {
		let neighbours = particles[i].checkDist();
		if (neighbours.length > 0) {
			for (let j = 0; j < neighbours.length; j++) {
				line(particles[i].pos.x, particles[i].pos.y, particles[neighbours[j]].pos.x, particles[neighbours[j]].pos.y);
			}
		}
	}

	// Black Hole
	for (var i = 0; i < bholes.length; i++) {
		noStroke();
		bholes[i].show();
	}

	// Sun
	for (var i = 0; i < suns.length; i++) {
		noStroke();
		suns[i].show();
	}

	// Particle
	for (var i = 0; i < particles.length; i++) {
		if (particles[i].offScreen()) {
			particles.splice(i, 1);
			newParticle();
		}
	}

	for (var i = 0; i < particles.length; i++) {
		particles[i].move();
		noStroke();
		particles[i].show();
	}


	// Black Hole: Gravity and Destruction
	for (let i = 0; i < bholes.length; i++) {
		let neighbours = bholes[i].checkDist();
		if (neighbours.length > 0) {
			for (let j = 0; j < neighbours.length; j++) {
				let curNeighbour = particles[neighbours[j]];

				let vecPartToHole = p5.Vector.sub(bholes[i].pos, curNeighbour.pos);

				if (vecPartToHole.mag() <= bholes[i].r - curNeighbour.r * 2) {
					if (curNeighbour.dying > 0) {
						curNeighbour.r = lerp(0, curNeighbour.initR, curNeighbour.dying);
						curNeighbour.dying = (curNeighbour.dying - curNeighbour.dyingRate < 0) ? 0 : curNeighbour.dying - curNeighbour.dyingRate;
					} else {
						particles.splice(neighbours[j], 1);
						newParticle();
					}
				}

				let distProp = (MAX_DISTANCE - vecPartToHole.mag()) / MAX_DISTANCE;

				curNeighbour.vel.add(p5.Vector.mult(vecPartToHole, distProp * GRAVITY));
			}
		}
	}

	// Sun: Gravity and Destruction and Light??
	for (let i = 0; i < suns.length; i++) {
		let neighbours = suns[i].checkDist();
		if (neighbours.length > 0) {
			for (let j = 0; j < neighbours.length; j++) {
				let curNeighbour = particles[neighbours[j]];

				let vecPartToHole = p5.Vector.sub(suns[i].pos, curNeighbour.pos);

				if (vecPartToHole.mag() <= suns[i].r - curNeighbour.r * 2) {
					if (curNeighbour.dying > 0) {
						curNeighbour.r = lerp(0, curNeighbour.initR, curNeighbour.dying);
						curNeighbour.dying = (curNeighbour.dying - curNeighbour.dyingRate < 0) ? 0 : curNeighbour.dying - curNeighbour.dyingRate;
					} else {
						particles.splice(neighbours[j], 1);
						newParticle();
					}
				}

				let distProp = (MAX_DISTANCE - vecPartToHole.mag()) / MAX_DISTANCE;

				curNeighbour.vel.add(p5.Vector.mult(vecPartToHole, distProp * GRAVITY));
			}
		}
	}

	// Shadows
	push();
	for (let i = 0; i < suns.length; i++) {
		for (var j = 0; j < particles.length; j++) {
			let curParticle = particles[j];

			let vecSunToPart = p5.Vector.sub(curParticle.pos, suns[i].pos);

			let PointR = p5.Vector.add(curParticle.pos, vecSunToPart.copy().rotate(90).normalize().mult(curParticle.r));
			let PointL = p5.Vector.add(curParticle.pos, vecSunToPart.copy().rotate(-90).normalize().mult(curParticle.r));

			fill(0, 30);
			noStroke();
			ellipse(PointL.x, PointL.y, 1, 1);
			ellipse(PointR.x, PointR.y, 1, 1);

			let rectEndR = PointR.copy().add(vecSunToPart.copy().setMag(windowWidth > windowHeight ? windowWidth * 2 : windowHeight * 2));
			let rectEndL = PointL.copy().add(vecSunToPart.copy().setMag(windowWidth > windowHeight ? windowWidth * 2 : windowHeight * 2));

			beginShape();

			vertex(PointL.x, PointL.y);
			vertex(PointR.x, PointR.y);
			vertex(rectEndR.x, rectEndR.y);
			vertex(rectEndL.x, rectEndL.y);

			endShape(CLOSE);

		}
	}
	pop();

	// it dark
	push();
	fill(0);
	noStroke();

	for (var i = 0; i < suns.length; i++) {
		let curSun = suns[i];
		if (windowWidth > windowHeight) {
			maxScreen = windowWidth;
			if (curSun.pos.x > windowWidth / 2) {
				rect(0, 0, curSun.pos.x - maxScreen / 2, windowHeight);

				if (curSun.pos.y > windowHeight / 2) {
					push();
					fill(255, 0, 0);
					rect(curSun.pos.x - maxScreen / 2, 0, windowWidth - curSun.pos.x - maxScreen / 2, windowHeight - maxScreen / 2 - curSun.pos.x);
					pop();
				}
			} else {
				rect(curSun.pos.x + maxScreen / 2, 0, windowWidth - curSun.pos.x + maxScreen / 2, windowHeight)
			}
		} else {
			maxScreen = windowHeight;
			if (curSun.pos.y > windowHeight / 2) {
				rect(0, 0, windowWidth, curSun.pos.y - maxScreen / 2)
			} else {
				rect(0, curSun.pos.y + maxScreen / 2, windowWidth, windowWidth - curSun.pos.y + maxScreen / 2)
			}
		}

		image(sun_overlay, curSun.pos.x - maxScreen / 2, curSun.pos.y - maxScreen / 2, maxScreen, maxScreen);
	}

	pop();

	push();
	fill(255);
	stroke(0);
	text("FPS: " + frameRate().toFixed(2), 10, height - 10);
	pop();
}

function mouseClicked() {
	if (keyIsDown(SHIFT)) {
		if (suns.length >= 1)
			suns = [];
		suns.push(new GravObj(createVector(mouseX, mouseY), SUN_R, SUN_COLOR, SUN_ALPHA, sunAnim));
	} else if (!keyIsDown(SHIFT))
		bholes.push(new GravObj(createVector(mouseX, mouseY), BHOLE_R, BHOLE_COLOR, BHOLE_ALPHA, bHoleAnim));
	return false;
}


function newParticle() {
	particles.push(new Particle(random(width), random(height)));
}

function updateGrid() {
	partGrid = [];

	for (let i = 0; i < gridWidth; i++) {
		partGrid.push([]);
		for (let k = 0; k < gridHeight; k++) {
			partGrid[i].push([]);
		}
	}

	for (let i = 0; i < particles.length; i++) {
		gridPos = particles[i].gridPos();
		partGrid[gridPos[0]][gridPos[1]].push(i);
	}


	holeGrid = [];

	for (let i = 0; i < gridWidth; i++) {
		holeGrid.push([]);
		for (let k = 0; k < gridHeight; k++) {
			holeGrid[i].push([]);
		}
	}

	for (let i = 0; i < bholes.length; i++) {
		gridPos = bholes[i].gridPos();
		holeGrid[gridPos[0]][gridPos[1]].push(i);
	}

	sunGrid = [];

	for (let i = 0; i < gridWidth; i++) {
		sunGrid.push([]);
		for (let k = 0; k < gridHeight; k++) {
			sunGrid[i].push([]);
		}
	}

	for (let i = 0; i < suns.length; i++) {
		gridPos = suns[i].gridPos();
		sunGrid[gridPos[0]][gridPos[1]].push(i);
	}

	grid = [];
	grid[0] = partGrid;
	grid[1] = holeGrid;
	grid[2] = sunGrid;
}


function createAnim(radius, angleDistance, nWaves, color, alpha, animSpeed, nFrames) {
	let anim = [];
	let animParticles = [];
	let nAnimParticles = floor(360 / angleDistance);

	let animSize = radius * 4;

	for (let i = 0; i < nWaves; i++) { // full
		for (let j = 0; j < nAnimParticles; j++) { // one wave
			let curAngle = (angleDistance * j) % 360;
			animParticles.push(new AnimParticle(createVector(animSize / 2, animSize / 2), radius, animSpeed, color, alpha, curAngle, (1 / nWaves) * i));
		}
	}

	for (let i = 0; i < nFrames; i++) {
		let curFrame = createGraphics(animSize, animSize);
		for (let p of animParticles) {
			p.show(curFrame);
			p.step();
		}

		anim.push(curFrame);
	}

	return anim;
}