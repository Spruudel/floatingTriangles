let debugging = false;

let particles = [];
let bholes = [];

let maxDistance = 180;
let gravity = 0.00009;

let grid;

let partGrid;
let holeGrid;

let gridWidth;
let gridHeight;


function setup() {
	createCanvas(windowWidth, windowHeight);
	frameRate(60);
	angleMode(DEGREES);

	var number = Math.floor((windowWidth * windowHeight) / 32914); // Generated by using (1920*1200) / x = 70, as this seemed to be okay
	for (let i = 0; i < number; i++) {
		particles.push(new Particle(random(width), random(height)));
	}

	gridWidth = ceil(windowWidth / maxDistance);
	gridHeight = ceil(windowHeight / maxDistance);
}

function draw() {
	background(51);

	updateGrid();

	if (debugging == true) {
		stroke(115, 100);
		for (let i = 0; i < gridWidth; i++) line(i * maxDistance, 0, i * maxDistance, windowHeight);

		for (let i = 0; i < gridHeight; i++) line(0, i * maxDistance, windowWidth, i * maxDistance);

		for (let x = 0; x < gridWidth; x++) {
			for (let y = 0; y < gridHeight; y++) {
				fill(255, 180);
				text(grid[0][x][y].length + grid[1][x][y].length, x * maxDistance + 10, y * maxDistance + 20);
			}
		}
	}

	// Particle
	for (var i = 0; i < particles.length; i++) {
		if (particles[i].offScreen()) {
			particles.splice(i, 1);
			newParticle();
		}
	}

	for (var i = 0; i < particles.length; i++) {
		particles[i].move();
		noStroke();
		particles[i].show();
	}


	stroke(115, 100);
	for (let i = 0; i < particles.length; i++) {
		let neighbours = particles[i].checkDist();
		if (neighbours.length > 0) {
			for (let j = 0; j < neighbours.length; j++) {
				line(particles[i].pos.x, particles[i].pos.y, particles[neighbours[j]].pos.x, particles[neighbours[j]].pos.y);
			}
		}
	}


	// Black Hole
	for (var i = 0; i < bholes.length; i++) {
		noStroke();
		bholes[i].show();
	}

	for (let i = 0; i < bholes.length; i++) {
		let neighbours = bholes[i].checkDist();
		if (neighbours.length > 0) {
			for (let j = 0; j < neighbours.length; j++) {
				//stroke(255, 20);
				//line(bholes[i].pos.x, bholes[i].pos.y, particles[neighbours[j]].pos.x, particles[neighbours[j]].pos.y);

				let vecPartToHole = p5.Vector.sub(bholes[i].pos, particles[neighbours[j]].pos);

				if (vecPartToHole.mag() <= bholes[i].r - particles[neighbours[j]].r * 2) {
					particles.splice(neighbours[j], 1);
					newParticle();
				}

				let distProp = (maxDistance - vecPartToHole.mag()) / maxDistance;

				particles[neighbours[j]].vel.add(p5.Vector.mult(vecPartToHole, distProp * gravity));
			}
		}
	}
}

function mouseClicked() {
	bholes.push(new BHole(mouseX, mouseY));
	return false;
}


function newParticle() {
	particles.push(new Particle(random(width), random(height)));
}

function updateGrid() {
	partGrid = [];

	for (let i = 0; i < gridWidth; i++) {
		partGrid.push([]);
		for (let k = 0; k < gridHeight; k++) {
			partGrid[i].push([]);
		}
	}

	for (let i = 0; i < particles.length; i++) {
		gridPos = particles[i].gridPos();
		partGrid[gridPos[0]][gridPos[1]].push(i);
	}


	holeGrid = [];

	for (let i = 0; i < gridWidth; i++) {
		holeGrid.push([]);
		for (let k = 0; k < gridHeight; k++) {
			holeGrid[i].push([]);
		}
	}

	for (let i = 0; i < bholes.length; i++) {
		gridPos = bholes[i].gridPos();
		holeGrid[gridPos[0]][gridPos[1]].push(i);
	}

	grid = [];
	grid[0] = partGrid;
	grid[1] = holeGrid;
}